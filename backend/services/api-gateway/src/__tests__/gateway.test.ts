/**
 * API Gateway Tests
 * Tests for API Gateway functionality including:
 * - Rate limiting
 * - JWT validation
 * - CORS headers
 * - Request routing
 * - Health checks
 * - Public routes
 * - Error handling
 */

import request from 'supertest';
import app from '../index';

// Mock JWT token for testing (would be generated by auth service in production)
const MOCK_VALID_TOKEN = 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMjM0NTY3OC05MGFiLWNkZWYtMTIzNC01Njc4OTBhYmNkZWYiLCJlbWFpbCI6InRlc3RAZXhhbXBsZS5jb20iLCJyb2xlIjoicGhhcm1hY2lzdCIsInBoYXJtYWN5SWQiOiI5ODc2NTQzMi0xMGFiLWNkZWYtMTIzNC01Njc4OTBhYmNkZWYiLCJ0eXBlIjoiYWNjZXNzIiwiaWF0IjoxNjQwOTk1MjAwLCJleHAiOjk5OTk5OTk5OTksImlzcyI6Im1ldGFwaGFybS1jb25uZWN0IiwiYXVkIjoibWV0YXBoYXJtLWFwaSJ9.invalid-signature';

describe('API Gateway', () => {
  // ============================================================================
  // Health Check Tests
  // ============================================================================

  describe('GET /health', () => {
    it('should return health status', async () => {
      const response = await request(app)
        .get('/health')
        .expect('Content-Type', /json/);

      expect(response.status).toBeGreaterThanOrEqual(200);
      expect(response.body).toHaveProperty('status');
      expect(response.body).toHaveProperty('timestamp');
      expect(response.body).toHaveProperty('gateway');
      expect(response.body).toHaveProperty('services');
    });

    it('should include gateway uptime and memory usage', async () => {
      const response = await request(app).get('/health');

      expect(response.body.gateway).toHaveProperty('status', 'healthy');
      expect(response.body.gateway).toHaveProperty('uptime');
      expect(response.body.gateway).toHaveProperty('memoryUsage');
      expect(response.body.gateway.memoryUsage).toHaveProperty('heapUsed');
      expect(response.body.gateway.memoryUsage).toHaveProperty('heapTotal');
    });
  });

  describe('GET /health/live', () => {
    it('should return liveness status', async () => {
      const response = await request(app)
        .get('/health/live')
        .expect(200)
        .expect('Content-Type', /json/);

      expect(response.body).toHaveProperty('status', 'alive');
      expect(response.body).toHaveProperty('timestamp');
    });
  });

  describe('GET /health/ready', () => {
    it('should return readiness status', async () => {
      const response = await request(app)
        .get('/health/ready')
        .expect('Content-Type', /json/);

      expect(response.body).toHaveProperty('status');
      expect(response.body).toHaveProperty('timestamp');
    });
  });

  // ============================================================================
  // Root Endpoint Test
  // ============================================================================

  describe('GET /', () => {
    it('should return gateway info', async () => {
      const response = await request(app)
        .get('/')
        .expect(200)
        .expect('Content-Type', /json/);

      expect(response.body).toHaveProperty('service', 'MetaPharm Connect API Gateway');
      expect(response.body).toHaveProperty('version');
      expect(response.body).toHaveProperty('status', 'running');
      expect(response.body).toHaveProperty('timestamp');
    });
  });

  // ============================================================================
  // CORS Tests
  // ============================================================================

  describe('CORS Configuration', () => {
    it('should include CORS headers in response', async () => {
      const response = await request(app)
        .get('/health')
        .set('Origin', 'http://localhost:3001');

      expect(response.headers).toHaveProperty('access-control-allow-origin');
    });

    it('should handle preflight OPTIONS request', async () => {
      const response = await request(app)
        .options('/health')
        .set('Origin', 'http://localhost:3001')
        .set('Access-Control-Request-Method', 'GET')
        .expect(204);

      expect(response.headers).toHaveProperty('access-control-allow-methods');
      expect(response.headers).toHaveProperty('access-control-allow-headers');
    });

    it('should include security headers', async () => {
      const response = await request(app).get('/health');

      expect(response.headers).toHaveProperty('x-content-type-options', 'nosniff');
      expect(response.headers).toHaveProperty('x-frame-options', 'DENY');
      expect(response.headers).toHaveProperty('x-xss-protection');
    });
  });

  // ============================================================================
  // Rate Limiting Tests
  // ============================================================================

  describe('Rate Limiting', () => {
    it('should include rate limit headers', async () => {
      const response = await request(app).get('/health');

      // express-rate-limit includes RateLimit-* headers
      expect(response.headers).toHaveProperty('ratelimit-limit');
      expect(response.headers).toHaveProperty('ratelimit-remaining');
    });

    // Note: Testing actual rate limit exhaustion requires many requests
    // and is better suited for integration tests
  });

  // ============================================================================
  // JWT Authentication Tests
  // ============================================================================

  describe('JWT Authentication', () => {
    it('should reject requests without token on protected routes', async () => {
      const response = await request(app)
        .get('/prescriptions')
        .expect(401)
        .expect('Content-Type', /json/);

      expect(response.body).toHaveProperty('error', 'Unauthorized');
      expect(response.body).toHaveProperty('code', 'NO_TOKEN');
    });

    it('should reject requests with invalid token', async () => {
      const response = await request(app)
        .get('/prescriptions')
        .set('Authorization', 'Bearer invalid-token')
        .expect(401)
        .expect('Content-Type', /json/);

      expect(response.body).toHaveProperty('error', 'Unauthorized');
      expect(response.body.code).toMatch(/INVALID_TOKEN|TOKEN_EXPIRED/);
    });

    it('should allow access to public routes without token', async () => {
      await request(app).get('/health').expect(200);
      await request(app).get('/').expect(200);
    });

    // Note: Testing with valid token requires proper JWT secret configuration
    // and is better suited for integration tests with actual auth service
  });

  // ============================================================================
  // Request Routing Tests
  // ============================================================================

  describe('Request Routing', () => {
    it('should proxy auth requests to auth service', async () => {
      // This will fail with 503 if auth service is not running (expected in unit tests)
      const response = await request(app)
        .post('/auth/login')
        .send({ email: 'test@example.com', password: 'password' });

      // We expect either a proxied response or 503 if service is down
      expect([401, 503]).toContain(response.status);
    });

    it('should proxy prescription requests to prescription service (requires auth)', async () => {
      const response = await request(app)
        .get('/prescriptions')
        .set('Authorization', 'Bearer invalid-token');

      // Should fail auth before reaching service
      expect(response.status).toBe(401);
    });
  });

  // ============================================================================
  // Error Handling Tests
  // ============================================================================

  describe('Error Handling', () => {
    it('should return 404 for unknown routes', async () => {
      const response = await request(app)
        .get('/unknown-route')
        .expect(404)
        .expect('Content-Type', /json/);

      expect(response.body).toHaveProperty('error', 'Not Found');
      expect(response.body).toHaveProperty('code', 'ROUTE_NOT_FOUND');
    });

    it('should handle invalid JSON payloads', async () => {
      const response = await request(app)
        .post('/auth/login')
        .set('Content-Type', 'application/json')
        .send('invalid json{')
        .expect(400);
    });
  });

  // ============================================================================
  // Request Logging Tests
  // ============================================================================

  describe('Request Logging', () => {
    it('should log requests (verified by no errors)', async () => {
      // If logging is broken, the request will fail
      await request(app).get('/health').expect(200);
    });
  });

  // ============================================================================
  // Service Availability Tests
  // ============================================================================

  describe('Service Availability', () => {
    it('should handle service unavailability gracefully', async () => {
      // With services down, requests should return 503
      const response = await request(app)
        .post('/auth/login')
        .send({ email: 'test@example.com', password: 'password' });

      // Either service responds or we get 503
      expect(response.status).toBeGreaterThanOrEqual(200);
    });
  });
});

// ============================================================================
// Integration Test Scenarios (commented out, run separately)
// ============================================================================

/*
describe('API Gateway Integration Tests', () => {
  // These tests require all microservices to be running
  // Run with: npm run test:integration

  it('should successfully authenticate and access protected route', async () => {
    // 1. Login to get valid token
    const loginResponse = await request(app)
      .post('/auth/login')
      .send({ email: 'pharmacist@example.com', password: 'password123' })
      .expect(200);

    const { accessToken } = loginResponse.body;

    // 2. Access protected route with token
    const response = await request(app)
      .get('/prescriptions')
      .set('Authorization', `Bearer ${accessToken}`)
      .expect(200);

    expect(response.body).toBeDefined();
  });

  it('should enforce rate limiting after threshold', async () => {
    const requests = [];

    // Send 101 requests (exceeds default limit of 100)
    for (let i = 0; i < 101; i++) {
      requests.push(request(app).get('/health'));
    }

    const responses = await Promise.all(requests);

    // Last request should be rate limited
    const lastResponse = responses[responses.length - 1];
    expect(lastResponse.status).toBe(429);
    expect(lastResponse.body.code).toBe('RATE_LIMIT_EXCEEDED');
  });

  it('should have all services healthy', async () => {
    const response = await request(app).get('/health').expect(200);

    expect(response.body.status).toBe('healthy');

    for (const service of Object.values(response.body.services)) {
      expect((service as any).status).toBe('healthy');
    }
  });
});
*/
